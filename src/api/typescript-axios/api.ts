// tslint:disable
/**
 * Pecori
 * # 新卒研修 Pecori のAPI仕様 ## 認証 - リクエストヘッダーに`X-PecoriToken: {トークン}`を含めてトークンを送信。 - X-PecoriToken ヘッダで送信するトークンは、`/login` APIのレスポンスから取得する。  ## 共通エラー一覧 全APIが返す可能性のある共通エラーを以下に示す。   なお、各APIが返却する可能性のあるエラーは各APIのレスポンス例を確認すること  <table>   <thead>     <tr>       <th>HTTP Status Code</th>       <th>code</th>       <th>description</th>       <th>発生条件</th>     </tr>   </thead>   <tbody>     <tr>       <td>500</td>       <td>1</td>       <td>接続に失敗しました</td>       <td>API の処理で何らかの例外が発生した時</td>     </tr>     <tr>       <td>500</td>       <td>2</td>       <td>接続に失敗しました</td>       <td>DBに接続できなかったとき</td>     </tr>     <tr>       <td>500</td>       <td>3</td>       <td>接続に失敗しました</td>       <td>DBからデータを取得できなかったとき(取得件数0の場合は除く)</td>     </tr>     <tr>       <td>401</td>       <td>4</td>       <td>再度ログインしてください</td>       <td>アクセストークンが無効・なにかしら不正だった場合</td>     </tr>     <tr>       <td>400</td>       <td>5</td>       <td>入力されたデータに誤りがあります</td>       <td>         必須となっているパラメータに値が入っていなかったとき<br>         またはパラメータに入っている値が予期しないものであったとき       </td>     </tr>   </tbody> </table> 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Admin
 */
export interface Admin {
    /**
     * ID
     * @type {number}
     * @memberof Admin
     */
    id: number;
    /**
     * 管理者名
     * @type {string}
     * @memberof Admin
     */
    name: string;
    /**
     * メールアドレス
     * @type {string}
     * @memberof Admin
     */
    email: string;
    /**
     * 登録日
     * @type {string}
     * @memberof Admin
     */
    createdAt: string;
}
/**
 * 
 * @export
 * @interface Article
 */
export interface Article {
    /**
     * ID
     * @type {number}
     * @memberof Article
     */
    id: number;
    /**
     * ユーザーID
     * @type {string}
     * @memberof Article
     */
    userId: string;
    /**
     * ニックネーム
     * @type {string}
     * @memberof Article
     */
    nickname: string;
    /**
     * いいね
     * @type {number}
     * @memberof Article
     */
    good: number;
    /**
     * 公開状態
     * @type {boolean}
     * @memberof Article
     */
    public: boolean;
    /**
     * 投稿日
     * @type {string}
     * @memberof Article
     */
    postedAt: string;
    /**
     * 最終更新日
     * @type {string}
     * @memberof Article
     */
    updatedAt: string;
    /**
     * コメント
     * @type {string}
     * @memberof Article
     */
    comment: string;
    /**
     * 画像パス
     * @type {string}
     * @memberof Article
     */
    image: string;
}
/**
 * 
 * @export
 * @interface FrozenRequest
 */
export interface FrozenRequest {
    /**
     * 凍結状態
     * @type {boolean}
     * @memberof FrozenRequest
     */
    frozen: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * メールアドレス
     * @type {string}
     * @memberof InlineObject
     */
    email: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {Admin}
     * @memberof InlineResponse200
     */
    admin: Admin;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    token: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {Array<User>}
     * @memberof InlineResponse2001
     */
    users: Array<User>;
    /**
     * 合計数
     * @type {number}
     * @memberof InlineResponse2001
     */
    total: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {Array<Admin>}
     * @memberof InlineResponse2002
     */
    admins: Array<Admin>;
    /**
     * 合計数
     * @type {number}
     * @memberof InlineResponse2002
     */
    total: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {Array<Article>}
     * @memberof InlineResponse2003
     */
    articles: Array<Article>;
    /**
     * 合計数
     * @type {number}
     * @memberof InlineResponse2003
     */
    total: number;
}
/**
 * 
 * @export
 * @interface InlineResponse400
 */
export interface InlineResponse400 {
    /**
     * 
     * @type {Array<Error>}
     * @memberof InlineResponse400
     */
    details?: Array<Error>;
}
/**
 * 
 * @export
 * @interface InlineResponse4001
 */
export interface InlineResponse4001 {
    /**
     * 
     * @type {Array<Error>}
     * @memberof InlineResponse4001
     */
    details?: Array<Error>;
}
/**
 * 
 * @export
 * @interface InlineResponse4002
 */
export interface InlineResponse4002 {
    /**
     * 
     * @type {Array<Error>}
     * @memberof InlineResponse4002
     */
    details?: Array<Error>;
}
/**
 * 
 * @export
 * @interface InlineResponse4003
 */
export interface InlineResponse4003 {
    /**
     * 
     * @type {Array<Error>}
     * @memberof InlineResponse4003
     */
    details?: Array<Error>;
}
/**
 * 
 * @export
 * @interface InlineResponse4004
 */
export interface InlineResponse4004 {
    /**
     * 
     * @type {Array<Error>}
     * @memberof InlineResponse4004
     */
    details?: Array<Error>;
}
/**
 * 
 * @export
 * @interface InlineResponse4005
 */
export interface InlineResponse4005 {
    /**
     * 
     * @type {Array<Error>}
     * @memberof InlineResponse4005
     */
    details?: Array<Error>;
}
/**
 * 
 * @export
 * @interface InlineResponse4006
 */
export interface InlineResponse4006 {
    /**
     * 
     * @type {Array<Error>}
     * @memberof InlineResponse4006
     */
    details?: Array<Error>;
}
/**
 * 
 * @export
 * @interface InlineResponse4007
 */
export interface InlineResponse4007 {
    /**
     * 
     * @type {Array<Error>}
     * @memberof InlineResponse4007
     */
    details?: Array<Error>;
}
/**
 * 
 * @export
 * @interface InlineResponse4008
 */
export interface InlineResponse4008 {
    /**
     * 
     * @type {Array<Error>}
     * @memberof InlineResponse4008
     */
    details?: Array<Error>;
}
/**
 * 
 * @export
 * @interface InlineResponse401
 */
export interface InlineResponse401 {
    /**
     * 
     * @type {Array<Error>}
     * @memberof InlineResponse401
     */
    details?: Array<Error>;
}
/**
 * 
 * @export
 * @interface InlineResponse4011
 */
export interface InlineResponse4011 {
    /**
     * 
     * @type {Array<Error>}
     * @memberof InlineResponse4011
     */
    details?: Array<Error>;
}
/**
 * 
 * @export
 * @interface InlineResponse403
 */
export interface InlineResponse403 {
    /**
     * 
     * @type {Array<Error>}
     * @memberof InlineResponse403
     */
    details?: Array<Error>;
}
/**
 * 
 * @export
 * @interface InlineResponse404
 */
export interface InlineResponse404 {
    /**
     * 
     * @type {Array<Error>}
     * @memberof InlineResponse404
     */
    details?: Array<Error>;
}
/**
 * 
 * @export
 * @interface InlineResponse4041
 */
export interface InlineResponse4041 {
    /**
     * 
     * @type {Array<Error>}
     * @memberof InlineResponse4041
     */
    details?: Array<Error>;
}
/**
 * 
 * @export
 * @interface InlineResponse4042
 */
export interface InlineResponse4042 {
    /**
     * 
     * @type {Array<Error>}
     * @memberof InlineResponse4042
     */
    details?: Array<Error>;
}
/**
 * 
 * @export
 * @interface InlineResponse4043
 */
export interface InlineResponse4043 {
    /**
     * 
     * @type {Array<Error>}
     * @memberof InlineResponse4043
     */
    details?: Array<Error>;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * メールアドレス
     * @type {string}
     * @memberof LoginRequest
     */
    email: string;
    /**
     * パスワード
     * @type {string}
     * @memberof LoginRequest
     */
    password: string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * エラーコード
     * @type {number}
     * @memberof ModelError
     */
    code: number;
    /**
     * エラーメッセージ
     * @type {string}
     * @memberof ModelError
     */
    description: string;
}
/**
 * 
 * @export
 * @interface PasswordResetRequest
 */
export interface PasswordResetRequest {
    /**
     * パスワード
     * @type {string}
     * @memberof PasswordResetRequest
     */
    password: string;
    /**
     * パスワード再確認
     * @type {string}
     * @memberof PasswordResetRequest
     */
    confirmPassword: string;
    /**
     * パスワードリセット用トークン
     * @type {string}
     * @memberof PasswordResetRequest
     */
    token: string;
}
/**
 * 
 * @export
 * @interface PostAdminRequest
 */
export interface PostAdminRequest {
    /**
     * 管理者名
     * @type {string}
     * @memberof PostAdminRequest
     */
    adminName: string;
    /**
     * メールアドレス
     * @type {string}
     * @memberof PostAdminRequest
     */
    email: string;
    /**
     * メールアドレス再確認
     * @type {string}
     * @memberof PostAdminRequest
     */
    confirmEmail?: string;
    /**
     * パスワード
     * @type {string}
     * @memberof PostAdminRequest
     */
    password: string;
}
/**
 * 
 * @export
 * @interface PutAdminEmailRequest
 */
export interface PutAdminEmailRequest {
    /**
     * メールアドレス
     * @type {string}
     * @memberof PutAdminEmailRequest
     */
    email: string;
    /**
     * メールアドレス再確認
     * @type {string}
     * @memberof PutAdminEmailRequest
     */
    confirmEmail: string;
}
/**
 * 
 * @export
 * @interface PutAdminNameRequest
 */
export interface PutAdminNameRequest {
    /**
     * 管理者名
     * @type {string}
     * @memberof PutAdminNameRequest
     */
    adminName: string;
}
/**
 * 
 * @export
 * @interface PutAdminPasswordRequest
 */
export interface PutAdminPasswordRequest {
    /**
     * パスワード
     * @type {string}
     * @memberof PutAdminPasswordRequest
     */
    currentPassword: string;
    /**
     * パスワード
     * @type {string}
     * @memberof PutAdminPasswordRequest
     */
    newPassword: string;
    /**
     * パスワード再確認
     * @type {string}
     * @memberof PutAdminPasswordRequest
     */
    confirmNewPassword: string;
}
/**
 * 
 * @export
 * @interface PutAdminPublicRequest
 */
export interface PutAdminPublicRequest {
    /**
     * 公開状態
     * @type {boolean}
     * @memberof PutAdminPublicRequest
     */
    public: boolean;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * ID
     * @type {number}
     * @memberof User
     */
    id: number;
    /**
     * ユーザーID
     * @type {string}
     * @memberof User
     */
    userId: string;
    /**
     * ニックネーム
     * @type {string}
     * @memberof User
     */
    nickname: string;
    /**
     * 画像パス
     * @type {string}
     * @memberof User
     */
    icon: string;
    /**
     * 紹介文
     * @type {string}
     * @memberof User
     */
    introduction: string;
    /**
     * 凍結状態
     * @type {boolean}
     * @memberof User
     */
    frozen: boolean;
    /**
     * 登録日時
     * @type {string}
     * @memberof User
     */
    createdAt: string;
}

/**
 * AdminsApi - axios parameter creator
 * @export
 */
export const AdminsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 管理者を追加する
         * @summary 管理者追加
         * @param {PostAdminRequest} [postAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAdmin: async (postAdminRequest?: PostAdminRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admins`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-PecoriToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-PecoriToken")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-PecoriToken"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof postAdminRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(postAdminRequest !== undefined ? postAdminRequest : {}) : (postAdminRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 管理者のメールアドレスを変更する。一般ユーザーが他の管理者のメールアドレスを変更しようとした場合 403 を返す。
         * @summary 管理者メールアドレス変更
         * @param {number} adminId 管理者ID
         * @param {PutAdminEmailRequest} [putAdminEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAdminEmailById: async (adminId: number, putAdminEmailRequest?: PutAdminEmailRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminId' is not null or undefined
            if (adminId === null || adminId === undefined) {
                throw new RequiredError('adminId','Required parameter adminId was null or undefined when calling changeAdminEmailById.');
            }
            const localVarPath = `/admins/{adminId}/email`
                .replace(`{${"adminId"}}`, encodeURIComponent(String(adminId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-PecoriToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-PecoriToken")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-PecoriToken"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof putAdminEmailRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(putAdminEmailRequest !== undefined ? putAdminEmailRequest : {}) : (putAdminEmailRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 管理者名を変更する。一般ユーザーが他の管理者の管理者名を変更しようとした場合 403 を返す。
         * @summary 管理者名変更
         * @param {number} adminId 管理者ID
         * @param {PutAdminNameRequest} [putAdminNameRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAdminNameById: async (adminId: number, putAdminNameRequest?: PutAdminNameRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminId' is not null or undefined
            if (adminId === null || adminId === undefined) {
                throw new RequiredError('adminId','Required parameter adminId was null or undefined when calling changeAdminNameById.');
            }
            const localVarPath = `/admins/{adminId}/name`
                .replace(`{${"adminId"}}`, encodeURIComponent(String(adminId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-PecoriToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-PecoriToken")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-PecoriToken"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof putAdminNameRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(putAdminNameRequest !== undefined ? putAdminNameRequest : {}) : (putAdminNameRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 管理者のパスワードを変更する。一般ユーザーが他の管理者のパスワードを変更しようとした場合 403 を返す。
         * @summary 管理者パスワード変更
         * @param {number} adminId 管理者ID
         * @param {PutAdminPasswordRequest} [putAdminPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAdminPasswordById: async (adminId: number, putAdminPasswordRequest?: PutAdminPasswordRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminId' is not null or undefined
            if (adminId === null || adminId === undefined) {
                throw new RequiredError('adminId','Required parameter adminId was null or undefined when calling changeAdminPasswordById.');
            }
            const localVarPath = `/admins/{adminId}/password`
                .replace(`{${"adminId"}}`, encodeURIComponent(String(adminId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-PecoriToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-PecoriToken")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-PecoriToken"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof putAdminPasswordRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(putAdminPasswordRequest !== undefined ? putAdminPasswordRequest : {}) : (putAdminPasswordRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 管理者を削除する。一般管理者の場合は 403 を返す。
         * @summary 管理者削除
         * @param {number} adminId 管理者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAdminById: async (adminId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminId' is not null or undefined
            if (adminId === null || adminId === undefined) {
                throw new RequiredError('adminId','Required parameter adminId was null or undefined when calling deleteAdminById.');
            }
            const localVarPath = `/admins/{adminId}`
                .replace(`{${"adminId"}}`, encodeURIComponent(String(adminId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-PecoriToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-PecoriToken")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-PecoriToken"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 管理者情報を取得する。一般管理者が他の管理者のページを開いた場合は 403 を返す。
         * @summary 管理者情報取得
         * @param {number} adminId 管理者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdminById: async (adminId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminId' is not null or undefined
            if (adminId === null || adminId === undefined) {
                throw new RequiredError('adminId','Required parameter adminId was null or undefined when calling getAdminById.');
            }
            const localVarPath = `/admins/{adminId}`
                .replace(`{${"adminId"}}`, encodeURIComponent(String(adminId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-PecoriToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-PecoriToken")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-PecoriToken"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 管理者の一覧を取得する。条件がある場合はクエリパラメータに追加する。
         * @summary 管理者一覧取得
         * @param {number} [page] ページ番号. 未指定の場合は１ページ目
         * @param {string} [sort] ソートする項目（管理者ID, 登録日など）
         * @param {'asc' | 'desc'} [orderBy] 昇順または降順(asc, desc). 未指定の場合はdesc
         * @param {string} [keyword] 名前またはメールアドレス
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdmins: async (page?: number, sort?: string, orderBy?: 'asc' | 'desc', keyword?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admins`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-PecoriToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-PecoriToken")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-PecoriToken"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminsApi - functional programming interface
 * @export
 */
export const AdminsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 管理者を追加する
         * @summary 管理者追加
         * @param {PostAdminRequest} [postAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAdmin(postAdminRequest?: PostAdminRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AdminsApiAxiosParamCreator(configuration).addAdmin(postAdminRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 管理者のメールアドレスを変更する。一般ユーザーが他の管理者のメールアドレスを変更しようとした場合 403 を返す。
         * @summary 管理者メールアドレス変更
         * @param {number} adminId 管理者ID
         * @param {PutAdminEmailRequest} [putAdminEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeAdminEmailById(adminId: number, putAdminEmailRequest?: PutAdminEmailRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AdminsApiAxiosParamCreator(configuration).changeAdminEmailById(adminId, putAdminEmailRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 管理者名を変更する。一般ユーザーが他の管理者の管理者名を変更しようとした場合 403 を返す。
         * @summary 管理者名変更
         * @param {number} adminId 管理者ID
         * @param {PutAdminNameRequest} [putAdminNameRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeAdminNameById(adminId: number, putAdminNameRequest?: PutAdminNameRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AdminsApiAxiosParamCreator(configuration).changeAdminNameById(adminId, putAdminNameRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 管理者のパスワードを変更する。一般ユーザーが他の管理者のパスワードを変更しようとした場合 403 を返す。
         * @summary 管理者パスワード変更
         * @param {number} adminId 管理者ID
         * @param {PutAdminPasswordRequest} [putAdminPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeAdminPasswordById(adminId: number, putAdminPasswordRequest?: PutAdminPasswordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AdminsApiAxiosParamCreator(configuration).changeAdminPasswordById(adminId, putAdminPasswordRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 管理者を削除する。一般管理者の場合は 403 を返す。
         * @summary 管理者削除
         * @param {number} adminId 管理者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAdminById(adminId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AdminsApiAxiosParamCreator(configuration).deleteAdminById(adminId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 管理者情報を取得する。一般管理者が他の管理者のページを開いた場合は 403 を返す。
         * @summary 管理者情報取得
         * @param {number} adminId 管理者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdminById(adminId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Admin>> {
            const localVarAxiosArgs = await AdminsApiAxiosParamCreator(configuration).getAdminById(adminId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 管理者の一覧を取得する。条件がある場合はクエリパラメータに追加する。
         * @summary 管理者一覧取得
         * @param {number} [page] ページ番号. 未指定の場合は１ページ目
         * @param {string} [sort] ソートする項目（管理者ID, 登録日など）
         * @param {'asc' | 'desc'} [orderBy] 昇順または降順(asc, desc). 未指定の場合はdesc
         * @param {string} [keyword] 名前またはメールアドレス
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdmins(page?: number, sort?: string, orderBy?: 'asc' | 'desc', keyword?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await AdminsApiAxiosParamCreator(configuration).getAdmins(page, sort, orderBy, keyword, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AdminsApi - factory interface
 * @export
 */
export const AdminsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 管理者を追加する
         * @summary 管理者追加
         * @param {PostAdminRequest} [postAdminRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAdmin(postAdminRequest?: PostAdminRequest, options?: any): AxiosPromise<void> {
            return AdminsApiFp(configuration).addAdmin(postAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 管理者のメールアドレスを変更する。一般ユーザーが他の管理者のメールアドレスを変更しようとした場合 403 を返す。
         * @summary 管理者メールアドレス変更
         * @param {number} adminId 管理者ID
         * @param {PutAdminEmailRequest} [putAdminEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAdminEmailById(adminId: number, putAdminEmailRequest?: PutAdminEmailRequest, options?: any): AxiosPromise<void> {
            return AdminsApiFp(configuration).changeAdminEmailById(adminId, putAdminEmailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 管理者名を変更する。一般ユーザーが他の管理者の管理者名を変更しようとした場合 403 を返す。
         * @summary 管理者名変更
         * @param {number} adminId 管理者ID
         * @param {PutAdminNameRequest} [putAdminNameRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAdminNameById(adminId: number, putAdminNameRequest?: PutAdminNameRequest, options?: any): AxiosPromise<void> {
            return AdminsApiFp(configuration).changeAdminNameById(adminId, putAdminNameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 管理者のパスワードを変更する。一般ユーザーが他の管理者のパスワードを変更しようとした場合 403 を返す。
         * @summary 管理者パスワード変更
         * @param {number} adminId 管理者ID
         * @param {PutAdminPasswordRequest} [putAdminPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAdminPasswordById(adminId: number, putAdminPasswordRequest?: PutAdminPasswordRequest, options?: any): AxiosPromise<void> {
            return AdminsApiFp(configuration).changeAdminPasswordById(adminId, putAdminPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 管理者を削除する。一般管理者の場合は 403 を返す。
         * @summary 管理者削除
         * @param {number} adminId 管理者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAdminById(adminId: number, options?: any): AxiosPromise<void> {
            return AdminsApiFp(configuration).deleteAdminById(adminId, options).then((request) => request(axios, basePath));
        },
        /**
         * 管理者情報を取得する。一般管理者が他の管理者のページを開いた場合は 403 を返す。
         * @summary 管理者情報取得
         * @param {number} adminId 管理者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdminById(adminId: number, options?: any): AxiosPromise<Admin> {
            return AdminsApiFp(configuration).getAdminById(adminId, options).then((request) => request(axios, basePath));
        },
        /**
         * 管理者の一覧を取得する。条件がある場合はクエリパラメータに追加する。
         * @summary 管理者一覧取得
         * @param {number} [page] ページ番号. 未指定の場合は１ページ目
         * @param {string} [sort] ソートする項目（管理者ID, 登録日など）
         * @param {'asc' | 'desc'} [orderBy] 昇順または降順(asc, desc). 未指定の場合はdesc
         * @param {string} [keyword] 名前またはメールアドレス
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdmins(page?: number, sort?: string, orderBy?: 'asc' | 'desc', keyword?: string, options?: any): AxiosPromise<InlineResponse2002> {
            return AdminsApiFp(configuration).getAdmins(page, sort, orderBy, keyword, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminsApi - object-oriented interface
 * @export
 * @class AdminsApi
 * @extends {BaseAPI}
 */
export class AdminsApi extends BaseAPI {
    /**
     * 管理者を追加する
     * @summary 管理者追加
     * @param {PostAdminRequest} [postAdminRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminsApi
     */
    public addAdmin(postAdminRequest?: PostAdminRequest, options?: any) {
        return AdminsApiFp(this.configuration).addAdmin(postAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 管理者のメールアドレスを変更する。一般ユーザーが他の管理者のメールアドレスを変更しようとした場合 403 を返す。
     * @summary 管理者メールアドレス変更
     * @param {number} adminId 管理者ID
     * @param {PutAdminEmailRequest} [putAdminEmailRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminsApi
     */
    public changeAdminEmailById(adminId: number, putAdminEmailRequest?: PutAdminEmailRequest, options?: any) {
        return AdminsApiFp(this.configuration).changeAdminEmailById(adminId, putAdminEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 管理者名を変更する。一般ユーザーが他の管理者の管理者名を変更しようとした場合 403 を返す。
     * @summary 管理者名変更
     * @param {number} adminId 管理者ID
     * @param {PutAdminNameRequest} [putAdminNameRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminsApi
     */
    public changeAdminNameById(adminId: number, putAdminNameRequest?: PutAdminNameRequest, options?: any) {
        return AdminsApiFp(this.configuration).changeAdminNameById(adminId, putAdminNameRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 管理者のパスワードを変更する。一般ユーザーが他の管理者のパスワードを変更しようとした場合 403 を返す。
     * @summary 管理者パスワード変更
     * @param {number} adminId 管理者ID
     * @param {PutAdminPasswordRequest} [putAdminPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminsApi
     */
    public changeAdminPasswordById(adminId: number, putAdminPasswordRequest?: PutAdminPasswordRequest, options?: any) {
        return AdminsApiFp(this.configuration).changeAdminPasswordById(adminId, putAdminPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 管理者を削除する。一般管理者の場合は 403 を返す。
     * @summary 管理者削除
     * @param {number} adminId 管理者ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminsApi
     */
    public deleteAdminById(adminId: number, options?: any) {
        return AdminsApiFp(this.configuration).deleteAdminById(adminId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 管理者情報を取得する。一般管理者が他の管理者のページを開いた場合は 403 を返す。
     * @summary 管理者情報取得
     * @param {number} adminId 管理者ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminsApi
     */
    public getAdminById(adminId: number, options?: any) {
        return AdminsApiFp(this.configuration).getAdminById(adminId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 管理者の一覧を取得する。条件がある場合はクエリパラメータに追加する。
     * @summary 管理者一覧取得
     * @param {number} [page] ページ番号. 未指定の場合は１ページ目
     * @param {string} [sort] ソートする項目（管理者ID, 登録日など）
     * @param {'asc' | 'desc'} [orderBy] 昇順または降順(asc, desc). 未指定の場合はdesc
     * @param {string} [keyword] 名前またはメールアドレス
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminsApi
     */
    public getAdmins(page?: number, sort?: string, orderBy?: 'asc' | 'desc', keyword?: string, options?: any) {
        return AdminsApiFp(this.configuration).getAdmins(page, sort, orderBy, keyword, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ArticlesApi - axios parameter creator
 * @export
 */
export const ArticlesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 記事の公開状態を変更する
         * @summary 記事公開状態変更
         * @param {number} articleId 投稿ID
         * @param {PutAdminPublicRequest} [putAdminPublicRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeArticlePublicById: async (articleId: number, putAdminPublicRequest?: PutAdminPublicRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'articleId' is not null or undefined
            if (articleId === null || articleId === undefined) {
                throw new RequiredError('articleId','Required parameter articleId was null or undefined when calling changeArticlePublicById.');
            }
            const localVarPath = `/articles/{articleId}/public`
                .replace(`{${"articleId"}}`, encodeURIComponent(String(articleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-PecoriToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-PecoriToken")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-PecoriToken"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof putAdminPublicRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(putAdminPublicRequest !== undefined ? putAdminPublicRequest : {}) : (putAdminPublicRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 記事を削除する。
         * @summary 記事削除
         * @param {number} articleId 投稿ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArticleById: async (articleId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'articleId' is not null or undefined
            if (articleId === null || articleId === undefined) {
                throw new RequiredError('articleId','Required parameter articleId was null or undefined when calling deleteArticleById.');
            }
            const localVarPath = `/articles/{articleId}`
                .replace(`{${"articleId"}}`, encodeURIComponent(String(articleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-PecoriToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-PecoriToken")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-PecoriToken"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 記事の詳細を取得する。
         * @summary 記事詳細取得
         * @param {number} articleId 投稿ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticleById: async (articleId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'articleId' is not null or undefined
            if (articleId === null || articleId === undefined) {
                throw new RequiredError('articleId','Required parameter articleId was null or undefined when calling getArticleById.');
            }
            const localVarPath = `/articles/{articleId}`
                .replace(`{${"articleId"}}`, encodeURIComponent(String(articleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-PecoriToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-PecoriToken")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-PecoriToken"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 記事一覧を取得する。条件がある場合はクエリパラメータを加える
         * @summary 記事一覧取得
         * @param {number} [page] ページ番号. 未指定の場合は１ページ目
         * @param {string} [keyword] キーワード
         * @param {string} [sort] ソートする項目（ユーザーID、登録日など）
         * @param {'asc' | 'desc'} [orderBy] 昇順または降順(asc, desc). 未指定の場合はdesc
         * @param {number} [userId] ユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticles: async (page?: number, keyword?: string, sort?: string, orderBy?: 'asc' | 'desc', userId?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/articles`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-PecoriToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-PecoriToken")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-PecoriToken"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArticlesApi - functional programming interface
 * @export
 */
export const ArticlesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 記事の公開状態を変更する
         * @summary 記事公開状態変更
         * @param {number} articleId 投稿ID
         * @param {PutAdminPublicRequest} [putAdminPublicRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeArticlePublicById(articleId: number, putAdminPublicRequest?: PutAdminPublicRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ArticlesApiAxiosParamCreator(configuration).changeArticlePublicById(articleId, putAdminPublicRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 記事を削除する。
         * @summary 記事削除
         * @param {number} articleId 投稿ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteArticleById(articleId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ArticlesApiAxiosParamCreator(configuration).deleteArticleById(articleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 記事の詳細を取得する。
         * @summary 記事詳細取得
         * @param {number} articleId 投稿ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArticleById(articleId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Article>> {
            const localVarAxiosArgs = await ArticlesApiAxiosParamCreator(configuration).getArticleById(articleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 記事一覧を取得する。条件がある場合はクエリパラメータを加える
         * @summary 記事一覧取得
         * @param {number} [page] ページ番号. 未指定の場合は１ページ目
         * @param {string} [keyword] キーワード
         * @param {string} [sort] ソートする項目（ユーザーID、登録日など）
         * @param {'asc' | 'desc'} [orderBy] 昇順または降順(asc, desc). 未指定の場合はdesc
         * @param {number} [userId] ユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArticles(page?: number, keyword?: string, sort?: string, orderBy?: 'asc' | 'desc', userId?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await ArticlesApiAxiosParamCreator(configuration).getArticles(page, keyword, sort, orderBy, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ArticlesApi - factory interface
 * @export
 */
export const ArticlesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 記事の公開状態を変更する
         * @summary 記事公開状態変更
         * @param {number} articleId 投稿ID
         * @param {PutAdminPublicRequest} [putAdminPublicRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeArticlePublicById(articleId: number, putAdminPublicRequest?: PutAdminPublicRequest, options?: any): AxiosPromise<void> {
            return ArticlesApiFp(configuration).changeArticlePublicById(articleId, putAdminPublicRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 記事を削除する。
         * @summary 記事削除
         * @param {number} articleId 投稿ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArticleById(articleId: number, options?: any): AxiosPromise<void> {
            return ArticlesApiFp(configuration).deleteArticleById(articleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 記事の詳細を取得する。
         * @summary 記事詳細取得
         * @param {number} articleId 投稿ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticleById(articleId: number, options?: any): AxiosPromise<Article> {
            return ArticlesApiFp(configuration).getArticleById(articleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 記事一覧を取得する。条件がある場合はクエリパラメータを加える
         * @summary 記事一覧取得
         * @param {number} [page] ページ番号. 未指定の場合は１ページ目
         * @param {string} [keyword] キーワード
         * @param {string} [sort] ソートする項目（ユーザーID、登録日など）
         * @param {'asc' | 'desc'} [orderBy] 昇順または降順(asc, desc). 未指定の場合はdesc
         * @param {number} [userId] ユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticles(page?: number, keyword?: string, sort?: string, orderBy?: 'asc' | 'desc', userId?: number, options?: any): AxiosPromise<InlineResponse2003> {
            return ArticlesApiFp(configuration).getArticles(page, keyword, sort, orderBy, userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArticlesApi - object-oriented interface
 * @export
 * @class ArticlesApi
 * @extends {BaseAPI}
 */
export class ArticlesApi extends BaseAPI {
    /**
     * 記事の公開状態を変更する
     * @summary 記事公開状態変更
     * @param {number} articleId 投稿ID
     * @param {PutAdminPublicRequest} [putAdminPublicRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public changeArticlePublicById(articleId: number, putAdminPublicRequest?: PutAdminPublicRequest, options?: any) {
        return ArticlesApiFp(this.configuration).changeArticlePublicById(articleId, putAdminPublicRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 記事を削除する。
     * @summary 記事削除
     * @param {number} articleId 投稿ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public deleteArticleById(articleId: number, options?: any) {
        return ArticlesApiFp(this.configuration).deleteArticleById(articleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 記事の詳細を取得する。
     * @summary 記事詳細取得
     * @param {number} articleId 投稿ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public getArticleById(articleId: number, options?: any) {
        return ArticlesApiFp(this.configuration).getArticleById(articleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 記事一覧を取得する。条件がある場合はクエリパラメータを加える
     * @summary 記事一覧取得
     * @param {number} [page] ページ番号. 未指定の場合は１ページ目
     * @param {string} [keyword] キーワード
     * @param {string} [sort] ソートする項目（ユーザーID、登録日など）
     * @param {'asc' | 'desc'} [orderBy] 昇順または降順(asc, desc). 未指定の場合はdesc
     * @param {number} [userId] ユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public getArticles(page?: number, keyword?: string, sort?: string, orderBy?: 'asc' | 'desc', userId?: number, options?: any) {
        return ArticlesApiFp(this.configuration).getArticles(page, keyword, sort, orderBy, userId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ログイン認証 正しいメールアドレスとパスワードであれば、200 を返す
         * @summary ログイン
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest?: LoginRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/login`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof loginRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(loginRequest !== undefined ? loginRequest : {}) : (loginRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーとのセッションを破棄する
         * @summary ログアウト
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/logout`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-PecoriToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-PecoriToken")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-PecoriToken"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 新しいパスワードに更新する
         * @summary パスワードリセット
         * @param {PasswordResetRequest} [passwordResetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (passwordResetRequest?: PasswordResetRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/password/reset`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof passwordResetRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(passwordResetRequest !== undefined ? passwordResetRequest : {}) : (passwordResetRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * パスワードリセット用のメールを送信する
         * @summary パスワードリセットメール
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail: async (inlineObject?: InlineObject, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/password/email`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject !== undefined ? inlineObject : {}) : (inlineObject || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * ログイン認証 正しいメールアドレスとパスワードであれば、200 を返す
         * @summary ログイン
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest?: LoginRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).login(loginRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーとのセッションを破棄する
         * @summary ログアウト
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).logout(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 新しいパスワードに更新する
         * @summary パスワードリセット
         * @param {PasswordResetRequest} [passwordResetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(passwordResetRequest?: PasswordResetRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).resetPassword(passwordResetRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * パスワードリセット用のメールを送信する
         * @summary パスワードリセットメール
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendEmail(inlineObject?: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).sendEmail(inlineObject, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * ログイン認証 正しいメールアドレスとパスワードであれば、200 を返す
         * @summary ログイン
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest?: LoginRequest, options?: any): AxiosPromise<InlineResponse200> {
            return AuthApiFp(configuration).login(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ユーザーとのセッションを破棄する
         * @summary ログアウト
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<void> {
            return AuthApiFp(configuration).logout(options).then((request) => request(axios, basePath));
        },
        /**
         * 新しいパスワードに更新する
         * @summary パスワードリセット
         * @param {PasswordResetRequest} [passwordResetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(passwordResetRequest?: PasswordResetRequest, options?: any): AxiosPromise<void> {
            return AuthApiFp(configuration).resetPassword(passwordResetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * パスワードリセット用のメールを送信する
         * @summary パスワードリセットメール
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail(inlineObject?: InlineObject, options?: any): AxiosPromise<void> {
            return AuthApiFp(configuration).sendEmail(inlineObject, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * ログイン認証 正しいメールアドレスとパスワードであれば、200 を返す
     * @summary ログイン
     * @param {LoginRequest} [loginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(loginRequest?: LoginRequest, options?: any) {
        return AuthApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ユーザーとのセッションを破棄する
     * @summary ログアウト
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logout(options?: any) {
        return AuthApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 新しいパスワードに更新する
     * @summary パスワードリセット
     * @param {PasswordResetRequest} [passwordResetRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public resetPassword(passwordResetRequest?: PasswordResetRequest, options?: any) {
        return AuthApiFp(this.configuration).resetPassword(passwordResetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * パスワードリセット用のメールを送信する
     * @summary パスワードリセットメール
     * @param {InlineObject} [inlineObject] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public sendEmail(inlineObject?: InlineObject, options?: any) {
        return AuthApiFp(this.configuration).sendEmail(inlineObject, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 指定したIDのユーザーを凍結状態を変更する
         * @summary ユーザー凍結
         * @param {number} userId ユーザーID
         * @param {FrozenRequest} [frozenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserFrozen: async (userId: number, frozenRequest?: FrozenRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling changeUserFrozen.');
            }
            const localVarPath = `/users/{userId}/frozen`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-PecoriToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-PecoriToken")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-PecoriToken"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof frozenRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(frozenRequest !== undefined ? frozenRequest : {}) : (frozenRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したIDのユーザーを削除する
         * @summary ユーザー削除
         * @param {number} userId ユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserById: async (userId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUserById.');
            }
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-PecoriToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-PecoriToken")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-PecoriToken"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したIDのユーザー情報を取得する
         * @summary ユーザー情報取得
         * @param {number} userId ユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (userId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUserById.');
            }
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-PecoriToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-PecoriToken")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-PecoriToken"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーの一覧を取得する。条件がある場合はクエリパラメータを加える
         * @summary ユーザー一覧取得
         * @param {number} [page] ページ番号. 未指定の場合は１ページ目
         * @param {string} [sort] ソートする項目（ユーザーID、登録日など）
         * @param {'asc' | 'desc'} [orderBy] 昇順または降順(asc, desc). 未指定の場合はdesc
         * @param {string} [keyword] キーワード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (page?: number, sort?: string, orderBy?: 'asc' | 'desc', keyword?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-PecoriToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-PecoriToken")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-PecoriToken"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 指定したIDのユーザーを凍結状態を変更する
         * @summary ユーザー凍結
         * @param {number} userId ユーザーID
         * @param {FrozenRequest} [frozenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeUserFrozen(userId: number, frozenRequest?: FrozenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).changeUserFrozen(userId, frozenRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したIDのユーザーを削除する
         * @summary ユーザー削除
         * @param {number} userId ユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserById(userId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).deleteUserById(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したIDのユーザー情報を取得する
         * @summary ユーザー情報取得
         * @param {number} userId ユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(userId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).getUserById(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーの一覧を取得する。条件がある場合はクエリパラメータを加える
         * @summary ユーザー一覧取得
         * @param {number} [page] ページ番号. 未指定の場合は１ページ目
         * @param {string} [sort] ソートする項目（ユーザーID、登録日など）
         * @param {'asc' | 'desc'} [orderBy] 昇順または降順(asc, desc). 未指定の場合はdesc
         * @param {string} [keyword] キーワード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(page?: number, sort?: string, orderBy?: 'asc' | 'desc', keyword?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).getUsers(page, sort, orderBy, keyword, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 指定したIDのユーザーを凍結状態を変更する
         * @summary ユーザー凍結
         * @param {number} userId ユーザーID
         * @param {FrozenRequest} [frozenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserFrozen(userId: number, frozenRequest?: FrozenRequest, options?: any): AxiosPromise<void> {
            return UsersApiFp(configuration).changeUserFrozen(userId, frozenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定したIDのユーザーを削除する
         * @summary ユーザー削除
         * @param {number} userId ユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserById(userId: number, options?: any): AxiosPromise<void> {
            return UsersApiFp(configuration).deleteUserById(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定したIDのユーザー情報を取得する
         * @summary ユーザー情報取得
         * @param {number} userId ユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(userId: number, options?: any): AxiosPromise<User> {
            return UsersApiFp(configuration).getUserById(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * ユーザーの一覧を取得する。条件がある場合はクエリパラメータを加える
         * @summary ユーザー一覧取得
         * @param {number} [page] ページ番号. 未指定の場合は１ページ目
         * @param {string} [sort] ソートする項目（ユーザーID、登録日など）
         * @param {'asc' | 'desc'} [orderBy] 昇順または降順(asc, desc). 未指定の場合はdesc
         * @param {string} [keyword] キーワード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(page?: number, sort?: string, orderBy?: 'asc' | 'desc', keyword?: string, options?: any): AxiosPromise<InlineResponse2001> {
            return UsersApiFp(configuration).getUsers(page, sort, orderBy, keyword, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 指定したIDのユーザーを凍結状態を変更する
     * @summary ユーザー凍結
     * @param {number} userId ユーザーID
     * @param {FrozenRequest} [frozenRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public changeUserFrozen(userId: number, frozenRequest?: FrozenRequest, options?: any) {
        return UsersApiFp(this.configuration).changeUserFrozen(userId, frozenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定したIDのユーザーを削除する
     * @summary ユーザー削除
     * @param {number} userId ユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUserById(userId: number, options?: any) {
        return UsersApiFp(this.configuration).deleteUserById(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定したIDのユーザー情報を取得する
     * @summary ユーザー情報取得
     * @param {number} userId ユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserById(userId: number, options?: any) {
        return UsersApiFp(this.configuration).getUserById(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ユーザーの一覧を取得する。条件がある場合はクエリパラメータを加える
     * @summary ユーザー一覧取得
     * @param {number} [page] ページ番号. 未指定の場合は１ページ目
     * @param {string} [sort] ソートする項目（ユーザーID、登録日など）
     * @param {'asc' | 'desc'} [orderBy] 昇順または降順(asc, desc). 未指定の場合はdesc
     * @param {string} [keyword] キーワード
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(page?: number, sort?: string, orderBy?: 'asc' | 'desc', keyword?: string, options?: any) {
        return UsersApiFp(this.configuration).getUsers(page, sort, orderBy, keyword, options).then((request) => request(this.axios, this.basePath));
    }

}


